//+------------------------------------------------------------------+
//|                                             ORB_SmartTrap_EA.mq5 |
//|                      Copyright 2023, Mtemi |
//|                                              https://www.example.com |
//+------------------------------------------------------------------+
#property copyright "Copyright 2023, Your Name"
#property link      "https://www.example.com"
#property version   "1.14"
#property description "Opening Range Breakout EA with advanced trap logic, trend filter, and session timing."

#include <Trade\Trade.mqh>

//--- Enums for User Inputs for better readability
enum ENUM_MONEY_MANAGEMENT
{
    RISK_PERCENT,    // Calculate lot size based on risk percentage
    FIXED_LOT        // Use a fixed lot size
};

enum ENUM_TRAP_TP_METHOD
{
    TP_OPPOSITE_RANGE, // Target the opposite side of the OR
    TP_FIXED_RR        // Use a fixed Risk:Reward ratio
};


//+------------------------------------------------------------------+
//| Expert Advisor Inputs                                            |
//+------------------------------------------------------------------+
//--- Opening Range Settings
input group           "Opening Range Settings"
input string          SessionStart        = "16:30";      // Opening Range Start Time (HH:MM server time)
input string          SessionEnd          = "16:45";      // Opening Range End Time (HH:MM server time)

//--- Trade Entry Settings
input group           "Trade Entry Settings"
input bool            enable_MarketBreakout = true;       // Trade on standard breakout candle?
input string          session_StopTime    = "18:00";      // Stop looking for new trades after this server time
input ulong           MagicNumber         = 13579;        // EA's unique magic number
input string          EaComment           = "ORB_EA";     // Comment for orders
input int             bufferTicks         = 2;            // Buffer in Ticks (Points) for Stop orders
input bool            oneTradePerSession  = true;         // Allow only one trade per day/session?

//--- Smart Trap Settings
input group           "Smart Trap Settings"
input bool            enable_SmartTrap      = true;       // Trade on trap/fakeout candle?
input ENUM_TRAP_TP_METHOD trap_TP_Method    = TP_OPPOSITE_RANGE; // Take Profit method for traps
input double          trap_FixedRR        = 3.0;          // Fixed RR for trap trades if selected

//--- Trend Filter Settings
input group           "Trend Filter Settings"
input bool            filter_Enable       = true;         // Enable Trend Filter?
input ENUM_TIMEFRAMES filter_Timeframe    = PERIOD_H1;    // Timeframe for the EMA
input int             filter_EmaPeriod    = 200;          // Period for the EMA

//--- Time-Based Exit Settings
input group           "Time-Based Exit Settings"
input bool            eod_EnableClose     = true;         // Enable End-of-Day close?
input string          eod_CloseTime       = "23:00";      // Server time to close trades (HH:MM)

//--- Stop Loss and Take Profit Settings
input group           "Stops and Targets"
input double          RiskRewardRatio     = 1.8;          // Risk:Reward Ratio for standard Take Profit calculation
input bool            UseSmartSL          = true;         // Use breakout candle for SL if it's large?
input double          SmartSLThreshold    = 1.2;          // Multiplier for Smart SL (e.g., 1.2 = 20% larger)

//--- Risk Management Settings
input group           "Risk Management"
input ENUM_MONEY_MANAGEMENT MoneyManagementMode = RISK_PERCENT;  // Lot sizing method
input double          RiskPercentPerTrade = 1.0;          // Risk % of account balance per trade
input double          FixedLotSize        = 0.01;         // Fixed lot size if selected
input double          MaxLotSize          = 10.0;         // Maximum allowed lot size

//--- Pyramiding Settings
input group           "Pyramiding Settings"
input bool            pyramid_Allow       = false;        // Enable adding to winning trades?
input int             pyramid_MaxEntries  = 2;            // Max number of additional entries
input double          pyramid_DistanceRR  = 0.5;          // Add position when in profit by X times initial risk (0.5 = 50%)
input double          pyramid_LotMultiplier = 1.0;      // Lot size multiplier for new entries
input bool            pyramid_MoveSLToBreakEven= true;         // Move SL to original entry price after adding?

//+------------------------------------------------------------------+
//| Global Variables                                                 |
//+------------------------------------------------------------------+
CTrade      trade;                     // Trading object
datetime    todayDate;                 // To track the current date
datetime    lastBarTime         = 0;     // For new bar detection
bool        isRangeFound        = false; // Flag if OR is calculated for the day
bool        isTradeTakenToday   = false; // Flag if a trade has been taken
bool        isPendingPlaced     = false; // Flag if pending Stop orders are on chart
bool        isEodCloseDoneToday = false; // Flag for End-of-Day close
bool        isFilterActive      = false; // Runtime status of the trend filter
double      orHigh              = 0.0;   // Opening Range High
double      orLow               = 0.0;   // Opening Range Low
datetime    orStartTime;                 // Calculated start time of the OR session
datetime    orEndTime;                   // Calculated end time of the OR session
int         ema_handle          = INVALID_HANDLE; // Handle for the EMA indicator

// Pyramiding state variables
int         pyramid_Count         = 0;     // Counter for additional entries
double      pyramid_InitialLotSize= 0.0;   // Stores the lot size of the first trade
double      pyramid_InitialEntryPrice= 0.0;   // Stores the entry price of the first trade
double      pyramid_InitialStopLoss  = 0.0;   // Stores the SL of the first trade

// Object names for visuals
string orBoxName = "OR_Box_" + (string)MagicNumber;
string entryLineName = "EntryLine_" + (string)MagicNumber;
string slLineName = "SLLine_" + (string)MagicNumber;
string tpLineName = "TPLine_" + (string)MagicNumber;


//+------------------------------------------------------------------+
//| Expert initialization function                                   |
//+------------------------------------------------------------------+
int OnInit()
{
    //--- Initialize trading object
    trade.SetExpertMagicNumber(MagicNumber);
    trade.SetTypeFillingBySymbol(_Symbol);
    trade.SetDeviationInPoints(5); // Allow small slippage
    
    // Initialize date and last bar time for new bar detection
    todayDate = (datetime)TimeCurrent();
    lastBarTime = iTime(_Symbol, _Period, 0);
    
    //--- Initialize EMA handle for trend filter
    if(filter_Enable)
    {
        ema_handle = iMA(_Symbol, filter_Timeframe, filter_EmaPeriod, 0, MODE_EMA, PRICE_CLOSE);
        if(ema_handle != INVALID_HANDLE)
        {
            isFilterActive = true; // Successfully initialized, so activate the filter
        }
        else
        {
            Print("Failed to create EMA indicator handle. Trend filter will be inactive.");
            isFilterActive = false; // Ensure it's false on failure
        }
    }
    
    PrintFormat("ORB SmartTrap EA v%s Initialized. Magic: %I64u", __MQL5_VERSION_STRING__, MagicNumber);
    PrintFormat("Symbol: %s, TimeFrame: %s", _Symbol, EnumToString(_Period));
    
    return(INIT_SUCCEEDED);
}

//+------------------------------------------------------------------+
//| Expert deinitialization function                                 |
//+------------------------------------------------------------------+
void OnDeinit(const int reason)
{
    //--- Clean up chart objects on exit
    DeleteVisuals();
    if(ema_handle != INVALID_HANDLE) IndicatorRelease(ema_handle);
    PrintFormat("ORB SmartTrap EA Deinitialized. Reason code: %d", reason);
}

//+------------------------------------------------------------------+
//| Expert tick function                                             |
//+------------------------------------------------------------------+
void OnTick()
{
    // --- New Bar Detection ---
    datetime newBarTime = iTime(_Symbol, _Period, 0);
    if(newBarTime > lastBarTime)
    {
        lastBarTime = newBarTime;
        OnNewBar(_Period); // Call the main logic on a new bar
    }
    
    // Check for pyramiding opportunities on every tick
    CheckForPyramiding();
    
    // Check for end-of-day close on every tick
    CheckForEodClose();
}


//+------------------------------------------------------------------+
//| New Bar Event Handler (Called from OnTick)                       |
//+------------------------------------------------------------------+
void OnNewBar(const int period)
{
    // Check for a new day to reset variables
    MqlDateTime current_dt, today_dt;
    TimeToStruct(TimeCurrent(), current_dt);
    TimeToStruct(todayDate, today_dt);
    
    if(current_dt.day != today_dt.day)
    {
        ResetDailyVariables();
    }
    
    // Check if the trading session for new entries is over
    if(IsSessionFinished())
    {
        return;
    }

    // --- Step 1: Find the Opening Range
    if(!isRangeFound)
    {
        if(FindOpeningRange())
        {
            isRangeFound = true;
            DrawOrBox();
        }
        else
        {
            // Still waiting for the OR session to complete
            return;
        }
    }
    
    // If range is found, proceed to check for trades
    if(isRangeFound && (!isTradeTakenToday || !oneTradePerSession))
    {
        // Cancel pending orders if position was closed manually or by SL/TP
        if(isPendingPlaced && PositionsTotal() == 0)
        {
            CancelPendingOrders();
        }
        
        CheckForBreakout();
    }
}

//+------------------------------------------------------------------+
//| Resets daily variables and cleans chart                          |
//+------------------------------------------------------------------+
void ResetDailyVariables()
{
    todayDate = (datetime)TimeCurrent();
    isRangeFound = false;
    isTradeTakenToday = false;
    isPendingPlaced = false;
    isEodCloseDoneToday = false;
    orHigh = 0.0;
    orLow = 0.0;
    
    // Reset pyramiding variables
    pyramid_Count = 0;
    pyramid_InitialLotSize = 0.0;
    pyramid_InitialEntryPrice = 0.0;
    pyramid_InitialStopLoss = 0.0;
    
    DeleteVisuals();
    
    Print("New day detected. Variables have been reset.");
}

//+------------------------------------------------------------------+
//| Finds the high and low of the opening range                      |
//+------------------------------------------------------------------+
bool FindOpeningRange()
{
    MqlDateTime start_dt, end_dt;
    
    // Parse start and end times from strings
    string start_parts[];
    if(StringSplit(SessionStart, ':', start_parts) == 2)
    {
       start_dt.hour = (int)StringToInteger(start_parts[0]);
       start_dt.min = (int)StringToInteger(start_parts[1]);
    }
    else
    {
       Print("Invalid SessionStart format. Please use HH:MM.");
       return false;
    }

    string end_parts[];
    if(StringSplit(SessionEnd, ':', end_parts) == 2)
    {
       end_dt.hour = (int)StringToInteger(end_parts[0]);
       end_dt.min = (int)StringToInteger(end_parts[1]);
    }
    else
    {
       Print("Invalid SessionEnd format. Please use HH:MM.");
       return false;
    }
    
    datetime now = TimeCurrent();
    MqlDateTime now_dt;
    TimeToStruct(now, now_dt);

    // Set the date parts for today
    start_dt.year = now_dt.year;
    start_dt.mon = now_dt.mon;
    start_dt.day = now_dt.day;
    end_dt.year = now_dt.year;
    end_dt.mon = now_dt.mon;
    end_dt.day = now_dt.day;
    
    orStartTime = StructToTime(start_dt);
    orEndTime = StructToTime(end_dt);

    // Check if the current time is past the OR session end time
    if(now < orEndTime)
    {
        return false; // Not time yet
    }

    // Get bar indexes for the session
    int bar1 = iBarShift(_Symbol, _Period, orStartTime);
    int bar2 = iBarShift(_Symbol, _Period, orEndTime);
    
    if(bar1 < 0 || bar2 < 0)
    {
        Print("Error finding bars for OR session. Check server time and session settings.");
        return false;
    }
    
    // Ensure correct ordering of bar indexes
    int startIndex = MathMax(bar1, bar2);
    int endIndex = MathMin(bar1, bar2);
    
    // Find the highest high and lowest low in the range
    double highs[], lows[];
    int barsInRange = startIndex - endIndex + 1;
    if(barsInRange <= 0)
    {
         Print("No bars found in the specified OR session.");
         return false;
    }

    if(CopyHigh(_Symbol, _Period, endIndex, barsInRange, highs) < 0 || CopyLow(_Symbol, _Period, endIndex, barsInRange, lows) < 0)
    {
        PrintFormat("Failed to copy price data for OR. Error: %d", GetLastError());
        return false;
    }
    
    orHigh = highs[ArrayMaximum(highs)];
    orLow = lows[ArrayMinimum(lows)];

    if(orHigh > 0 && orLow > 0)
    {
        PrintFormat("Opening Range Found for %s. High: %.5f, Low: %.5f", TimeToString(todayDate, TIME_DATE), orHigh, orLow);
        return true;
    }

    return false;
}

//+------------------------------------------------------------------+
//| Checks for a breakout of the Opening Range                       |
//+------------------------------------------------------------------+
void CheckForBreakout()
{
    // Use the last closed bar for analysis (index 1)
    double closePrice = iClose(_Symbol, _Period, 1);
    double openPrice = iOpen(_Symbol, _Period, 1);
    double highPrice = iHigh(_Symbol, _Period, 1);
    double lowPrice = iLow(_Symbol, _Period, 1);
    
    bool isBullishCandle = closePrice > openPrice;
    bool isBearishCandle = closePrice < openPrice;
    
    // --- Trend Filter Logic ---
    if(isFilterActive)
    {
        double ema_buffer[];
        if(CopyBuffer(ema_handle, 0, 0, 1, ema_buffer) <= 0)
        {
            Print("Could not get EMA value. Skipping trade check.");
            return;
        }
        double emaValue = ema_buffer[0];
        
        // --- Bullish Breakout Scenario (candle closed above OR High) ---
        if(closePrice > orHigh)
        {
            // Smart Trap (SELL) requires price to be BELOW EMA for confirmation
            if(enable_SmartTrap && isBearishCandle && closePrice < emaValue)
            {
                ExecuteSmartTrap(ORDER_TYPE_SELL, highPrice, lowPrice);
            }
            // Market Breakout (BUY) requires price to be ABOVE EMA
            else if(enable_MarketBreakout && isBullishCandle && closePrice > emaValue)
            {
                ExecuteTrade(ORDER_TYPE_BUY, closePrice, 1);
            }
        }
        // --- Bearish Breakout Scenario (candle closed below OR Low) ---
        else if(closePrice < orLow)
        {
            // Smart Trap (BUY) requires price to be ABOVE EMA for confirmation
            if(enable_SmartTrap && isBullishCandle && closePrice > emaValue)
            {
                 ExecuteSmartTrap(ORDER_TYPE_BUY, highPrice, lowPrice);
            }
            // Market Breakout (SELL) requires price to be BELOW EMA
            else if(enable_MarketBreakout && isBearishCandle && closePrice < emaValue)
            {
                ExecuteTrade(ORDER_TYPE_SELL, closePrice, 1);
            }
        }
    }
    // --- Logic without Trend Filter ---
    else
    {
        // --- Bullish Breakout Scenario ---
        if(closePrice > orHigh)
        {
            if(enable_SmartTrap && isBearishCandle) ExecuteSmartTrap(ORDER_TYPE_SELL, highPrice, lowPrice);
            else if(enable_MarketBreakout && isBullishCandle) ExecuteTrade(ORDER_TYPE_BUY, closePrice, 1);
        }
        // --- Bearish Breakout Scenario ---
        else if(closePrice < orLow)
        {
            if(enable_SmartTrap && isBullishCandle) ExecuteSmartTrap(ORDER_TYPE_BUY, highPrice, lowPrice);
            else if(enable_MarketBreakout && isBearishCandle) ExecuteTrade(ORDER_TYPE_SELL, closePrice, 1);
        }
    }
}

//+------------------------------------------------------------------+
//| Executes a market order trade                                    |
//+------------------------------------------------------------------+
void ExecuteTrade(ENUM_ORDER_TYPE orderType, double entryPrice, int barIndex)
{
    double stopLoss = 0.0;
    double takeProfit = 0.0;
    
    // --- Determine Stop Loss ---
    if(UseSmartSL)
    {
        double breakoutCandleHigh = iHigh(_Symbol, _Period, barIndex);
        double breakoutCandleLow = iLow(_Symbol, _Period, barIndex);
        double candleRange = breakoutCandleHigh - breakoutCandleLow;
        double orRange = orHigh - orLow;
        
        if(candleRange > (orRange * SmartSLThreshold))
        {
            stopLoss = (orderType == ORDER_TYPE_BUY) ? breakoutCandleLow : breakoutCandleHigh;
            Print("Smart SL activated.");
        }
        else
        {
            stopLoss = (orderType == ORDER_TYPE_BUY) ? orLow : orHigh;
        }
    }
    else
    {
        stopLoss = (orderType == ORDER_TYPE_BUY) ? orLow : orHigh;
    }
    
    // --- Calculate Take Profit ---
    double slDistance = MathAbs(entryPrice - stopLoss);
    takeProfit = (orderType == ORDER_TYPE_BUY) ? entryPrice + (slDistance * RiskRewardRatio) : entryPrice - (slDistance * RiskRewardRatio);
    
    // --- Calculate Lot Size ---
    double lotSize = CalculateLotSize(entryPrice, stopLoss);
    if(lotSize <= 0)
    {
        Print("Lot size calculation failed. No trade executed.");
        return;
    }

    // --- Execute Trade ---
    bool result = false;
    if(orderType == ORDER_TYPE_BUY)
    {
        result = trade.Buy(lotSize, _Symbol, entryPrice, stopLoss, takeProfit, EaComment);
    }
    else if(orderType == ORDER_TYPE_SELL)
    {
        result = trade.Sell(lotSize, _Symbol, entryPrice, stopLoss, takeProfit, EaComment);
    }
    
    if(result && trade.ResultRetcode() == TRADE_RETCODE_DONE)
    {
        isTradeTakenToday = true;
        PrintFormat("%s Trade Executed @ %.5f, SL: %.5f, TP: %.5f, Lots: %.2f", (orderType == ORDER_TYPE_BUY ? "BUY" : "SELL"), trade.ResultPrice(), stopLoss, takeProfit, lotSize);
        pyramid_InitialEntryPrice = trade.ResultPrice();
        pyramid_InitialStopLoss = stopLoss;
        pyramid_InitialLotSize = lotSize;
        DrawTradeLines(trade.ResultPrice(), stopLoss, takeProfit);
    }
    else
    {
        PrintFormat("Order execution failed. Error: %d - %s", trade.ResultRetcode(), trade.ResultComment());
    }
}

//+------------------------------------------------------------------+
//| Executes a pending limit order for a Smart Trap                  |
//+------------------------------------------------------------------+
void ExecuteSmartTrap(ENUM_ORDER_TYPE orderType, double candleHigh, double candleLow)
{
    double entryPrice = 0, stopLoss = 0, takeProfit = 0;

    // Calculate the midpoint of the opening range, this is our entry
    double midPoint = (orHigh + orLow) / 2.0;
    
    if(orderType == ORDER_TYPE_BUY) // Bear Trap (bullish candle breaks low, expecting reversal UP)
    {
        Print("Trap detected! Bullish candle on bearish breakout. Placing Buy Limit at OR Midpoint.");
        entryPrice = midPoint;
        stopLoss = candleLow; // SL is the low of the breakout candle

        if(trap_TP_Method == TP_OPPOSITE_RANGE)
        {
            takeProfit = orHigh;
        }
        else // TP_FIXED_RR
        {
            double riskDistance = MathAbs(entryPrice - stopLoss);
            takeProfit = entryPrice + (riskDistance * trap_FixedRR);
        }
    }
    else // Bull Trap (bearish candle breaks high, expecting reversal DOWN)
    {
        Print("Trap detected! Bearish candle on bullish breakout. Placing Sell Limit at OR Midpoint.");
        entryPrice = midPoint;
        stopLoss = candleHigh; // SL is the high of the breakout candle

        if(trap_TP_Method == TP_OPPOSITE_RANGE)
        {
            takeProfit = orLow;
        }
        else // TP_FIXED_RR
        {
            double riskDistance = MathAbs(entryPrice - stopLoss);
            takeProfit = entryPrice - (riskDistance * trap_FixedRR);
        }
    }
    
    //--- Validate that the limit order can be placed ---
    if(orderType == ORDER_TYPE_BUY)
    {
       if(entryPrice >= SymbolInfoDouble(_Symbol, SYMBOL_ASK))
       {
           PrintFormat("Cannot place Buy Limit. Entry price %.5f is not below current Ask price %.5f.", entryPrice, SymbolInfoDouble(_Symbol, SYMBOL_ASK));
           return;
       }
    }
    else // ORDER_TYPE_SELL
    {
       if(entryPrice <= SymbolInfoDouble(_Symbol, SYMBOL_BID))
       {
           PrintFormat("Cannot place Sell Limit. Entry price %.5f is not above current Bid price %.5f.", entryPrice, SymbolInfoDouble(_Symbol, SYMBOL_BID));
           return;
       }
    }
    
    //--- Calculate Lot Size and Place the Limit Order ---
    double lotSize = CalculateLotSize(entryPrice, stopLoss);
    if(lotSize > 0)
    {
        bool result = false;
        if(orderType == ORDER_TYPE_BUY) result = trade.BuyLimit(lotSize, entryPrice, _Symbol, stopLoss, takeProfit, ORDER_TIME_GTC, 0, EaComment + "_Trap");
        else result = trade.SellLimit(lotSize, entryPrice, _Symbol, stopLoss, takeProfit, ORDER_TIME_GTC, 0, EaComment + "_Trap");

        if(result && trade.ResultRetcode() == TRADE_RETCODE_DONE)
        {
            isPendingPlaced = true;
            PrintFormat("Smart Trap %s Limit order placed.", (orderType == ORDER_TYPE_BUY ? "Buy" : "Sell"));
        }
    }
}


//+------------------------------------------------------------------+
//| Calculates lot size based on risk settings                       |
//+------------------------------------------------------------------+
double CalculateLotSize(double entryPrice, double stopLossPrice)
{
    if(MoneyManagementMode == FIXED_LOT)
    {
        return(FixedLotSize);
    }

    double lotSize = 0.0;
    double accountBalance = AccountInfoDouble(ACCOUNT_BALANCE);
    double slDistance = MathAbs(entryPrice - stopLossPrice);
    
    if(slDistance <= 0)
    {
        Print("Stop loss distance is zero, cannot calculate lot size.");
        return 0.0;
    }
    
    double tickValue = SymbolInfoDouble(_Symbol, SYMBOL_TRADE_TICK_VALUE);
    double tickSize = SymbolInfoDouble(_Symbol, SYMBOL_TRADE_TICK_SIZE);
    
    if(tickValue <= 0 || tickSize <= 0)
    {
        Print("Invalid Tick Value or Tick Size. Cannot calculate lot size.");
        return 0.0;
    }

    double riskAmount = accountBalance * (RiskPercentPerTrade / 100.0);
    double lossPerLot = slDistance / tickSize * tickValue;

    if(lossPerLot > 0)
    {
        lotSize = riskAmount / lossPerLot;
    }

    double volMin = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_MIN);
    double volMax = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_MAX);
    double volStep = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_STEP);
    
    lotSize = MathFloor(lotSize / volStep) * volStep;
    
    if(lotSize < volMin) lotSize = volMin;
    if(lotSize > volMax) lotSize = volMax;
    if(lotSize > MaxLotSize) lotSize = MaxLotSize;
    
    return(lotSize);
}


//+------------------------------------------------------------------+
//| Event handler for trade transactions                             |
//+------------------------------------------------------------------+
void OnTradeTransaction(const MqlTradeTransaction& trans,
                        const MqlTradeRequest& request,
                        const MqlTradeResult& result)
{
    if(isPendingPlaced)
    {
        if(trans.type == TRADE_TRANSACTION_DEAL_ADD && (trans.deal_type == DEAL_TYPE_BUY || trans.deal_type == DEAL_TYPE_SELL))
        {
            if(trans.position > 0 && PositionSelectByTicket(trans.position))
            {
                if(PositionGetInteger(POSITION_MAGIC) == MagicNumber)
                {
                    Print("A pending order was triggered. A position has been opened.");
                    isTradeTakenToday = true;
                    isPendingPlaced = false;
                    CancelPendingOrders();

                    double entry = trans.price;
                    double sl = PositionGetDouble(POSITION_SL);
                    double tp = PositionGetDouble(POSITION_TP);
                    
                    pyramid_InitialEntryPrice = entry;
                    pyramid_InitialStopLoss = sl;
                    pyramid_InitialLotSize = PositionGetDouble(POSITION_VOLUME);
                    
                    DrawTradeLines(entry, sl, tp);
                }
            }
        }
    }
}


//+------------------------------------------------------------------+
//| Cancels all pending orders for this EA                           |
//+------------------------------------------------------------------+
void CancelPendingOrders()
{
    int totalOrders = OrdersTotal();
    for(int i = totalOrders - 1; i >= 0; i--)
    {
        ulong ticket = OrderGetTicket(i);
        if(OrderSelect(ticket))
        {
            if(OrderGetString(ORDER_SYMBOL) == _Symbol && OrderGetInteger(ORDER_MAGIC) == MagicNumber)
            {
                if(trade.OrderDelete(ticket))
                {
                    PrintFormat("Cancelled pending order #%I64u", ticket);
                }
            }
        }
    }
    isPendingPlaced = false;
}

//+------------------------------------------------------------------+
//| Checks if the trading session for new entries is over            |
//+------------------------------------------------------------------+
bool IsSessionFinished()
{
    // Parse stop time from string
    MqlDateTime dt_stop;
    string time_parts[];
    if(StringSplit(session_StopTime, ':', time_parts) != 2)
    {
        Print("Invalid session_StopTime format. Please use HH:MM. Trading will continue.");
        return false; // Fail-safe, continue trading
    }
    dt_stop.hour = (int)StringToInteger(time_parts[0]);
    dt_stop.min  = (int)StringToInteger(time_parts[1]);

    // Get current time
    datetime now = TimeCurrent();
    MqlDateTime dt_now;
    TimeToStruct(now, dt_now);

    // Check if current time is past the stop trading time
    if(dt_now.hour > dt_stop.hour || (dt_now.hour == dt_stop.hour && dt_now.min >= dt_stop.min))
    {
        return true;
    }

    return false;
}


//+------------------------------------------------------------------+
//| Manages adding positions to a winning trade                      |
//+------------------------------------------------------------------+
void CheckForPyramiding()
{
    if(!pyramid_Allow || PositionsTotal() == 0 || pyramid_Count >= pyramid_MaxEntries || pyramid_InitialEntryPrice == 0.0)
    {
        return;
    }
    
    if(!PositionSelect(_Symbol)) return;
    if(PositionGetInteger(POSITION_MAGIC) != MagicNumber) return;
    
    long positionType = PositionGetInteger(POSITION_TYPE);
    double currentSL = PositionGetDouble(POSITION_SL);
    double currentTP = PositionGetDouble(POSITION_TP);
    
    double initialRiskDistance = MathAbs(pyramid_InitialEntryPrice - pyramid_InitialStopLoss);
    if(initialRiskDistance == 0) return;
    
    double profitTargetDistance = initialRiskDistance * (pyramid_DistanceRR * (pyramid_Count + 1));
    
    double pyramidTriggerPrice = 0;
    if(positionType == POSITION_TYPE_BUY)
    {
        pyramidTriggerPrice = pyramid_InitialEntryPrice + profitTargetDistance;
        if(SymbolInfoDouble(_Symbol, SYMBOL_BID) > pyramidTriggerPrice)
        {
             double newLotSize = pyramid_InitialLotSize * pyramid_LotMultiplier;
             if(trade.Buy(newLotSize, _Symbol, 0, currentSL, currentTP, EaComment + "_pyramid"))
             {
                 PrintFormat("Pyramid BUY entry added. Count: %d", pyramid_Count + 1);
                 pyramid_Count++;
                 if(pyramid_MoveSLToBreakEven) MoveSLToBreakEven();
             }
        }
    }
    else if(positionType == POSITION_TYPE_SELL)
    {
        pyramidTriggerPrice = pyramid_InitialEntryPrice - profitTargetDistance;
        if(SymbolInfoDouble(_Symbol, SYMBOL_ASK) < pyramidTriggerPrice)
        {
             double newLotSize = pyramid_InitialLotSize * pyramid_LotMultiplier;
             if(trade.Sell(newLotSize, _Symbol, 0, currentSL, currentTP, EaComment + "_pyramid"))
             {
                 PrintFormat("Pyramid SELL entry added. Count: %d", pyramid_Count + 1);
                 pyramid_Count++;
                 if(pyramid_MoveSLToBreakEven) MoveSLToBreakEven();
             }
        }
    }
}

//+------------------------------------------------------------------+
//| Moves Stop Loss to initial entry price for all open positions    |
//+------------------------------------------------------------------+
void MoveSLToBreakEven()
{
    if(pyramid_InitialEntryPrice == 0.0) return;
    
    PrintFormat("Moving Stop Loss to Break-Even at %.5f", pyramid_InitialEntryPrice);
    
    for(int i = PositionsTotal() - 1; i >= 0; i--)
    {
        ulong ticket = PositionGetTicket(i);
        if(PositionSelectByTicket(ticket))
        {
             if(PositionGetString(POSITION_SYMBOL) == _Symbol && PositionGetInteger(POSITION_MAGIC) == MagicNumber)
             {
                  double currentTP = PositionGetDouble(POSITION_TP);
                  trade.PositionModify(ticket, pyramid_InitialEntryPrice, currentTP);
             }
        }
    }
}

//+------------------------------------------------------------------+
//| Closes open positions at the specified End-of-Day time           |
//+------------------------------------------------------------------+
void CheckForEodClose()
{
    if(!eod_EnableClose || PositionsTotal() == 0 || isEodCloseDoneToday)
    {
        return;
    }
    
    // Parse close time from string
    MqlDateTime dt_close;
    string time_parts[];
    if(StringSplit(eod_CloseTime, ':', time_parts) != 2) return; // Invalid format
    dt_close.hour = (int)StringToInteger(time_parts[0]);
    dt_close.min = (int)StringToInteger(time_parts[1]);
    
    // Get current time
    datetime now = TimeCurrent();
    MqlDateTime dt_now;
    TimeToStruct(now, dt_now);
    
    // Check if it's time to close
    if(dt_now.hour > dt_close.hour || (dt_now.hour == dt_close.hour && dt_now.min >= dt_close.min))
    {
        PrintFormat("End of Day Close time reached (%s). Closing open positions.", eod_CloseTime);
        for(int i = PositionsTotal() - 1; i >= 0; i--)
        {
            ulong ticket = PositionGetTicket(i);
            if(PositionSelectByTicket(ticket))
            {
                if(PositionGetString(POSITION_SYMBOL) == _Symbol && PositionGetInteger(POSITION_MAGIC) == MagicNumber)
                {
                    trade.PositionClose(ticket);
                }
            }
        }
        isEodCloseDoneToday = true; // Set flag to prevent re-closing
    }
}

//+------------------------------------------------------------------+
//| Visual Functions                                                 |
//+------------------------------------------------------------------+
void DrawOrBox()
{
    ObjectCreate(0, orBoxName, OBJ_RECTANGLE, 0, orStartTime, orHigh, orEndTime, orLow);
    ObjectSetInteger(0, orBoxName, OBJPROP_COLOR, clrDodgerBlue);
    ObjectSetInteger(0, orBoxName, OBJPROP_STYLE, STYLE_DOT);
    ObjectSetInteger(0, orBoxName, OBJPROP_BACK, true);
    ObjectSetInteger(0, orBoxName, OBJPROP_SELECTABLE, false);
    ChartRedraw();
}

void DrawTradeLines(double entry, double sl, double tp)
{
    ObjectCreate(0, entryLineName, OBJ_HLINE, 0, 0, entry);
    ObjectSetInteger(0, entryLineName, OBJPROP_COLOR, clrGreen);
    ObjectSetInteger(0, entryLineName, OBJPROP_STYLE, STYLE_SOLID);
    ObjectSetInteger(0, entryLineName, OBJPROP_WIDTH, 2);
    ObjectSetString(0, entryLineName, OBJPROP_TEXT, "Entry");
    ObjectSetInteger(0, entryLineName, OBJPROP_SELECTABLE, false);
    
    ObjectCreate(0, slLineName, OBJ_HLINE, 0, 0, sl);
    ObjectSetInteger(0, slLineName, OBJPROP_COLOR, clrRed);
    ObjectSetInteger(0, slLineName, OBJPROP_STYLE, STYLE_DASH);
    ObjectSetInteger(0, slLineName, OBJPROP_WIDTH, 2);
    ObjectSetString(0, slLineName, OBJPROP_TEXT, "Stop Loss");
    ObjectSetInteger(0, slLineName, OBJPROP_SELECTABLE, false);
    
    ObjectCreate(0, tpLineName, OBJ_HLINE, 0, 0, tp);
    ObjectSetInteger(0, tpLineName, OBJPROP_COLOR, clrBlue);
    ObjectSetInteger(0, tpLineName, OBJPROP_STYLE, STYLE_DASH);
    ObjectSetInteger(0, tpLineName, OBJPROP_WIDTH, 2);
    ObjectSetString(0, tpLineName, OBJPROP_TEXT, "Take Profit");
    ObjectSetInteger(0, tpLineName, OBJPROP_SELECTABLE, false);
    
    ChartRedraw();
}

void DeleteVisuals()
{
    ObjectDelete(0, orBoxName);
    ObjectDelete(0, entryLineName);
    ObjectDelete(0, slLineName);
    ObjectDelete(0, tpLineName);
    ChartRedraw();
}
//+------------------------------------------------------------------+
//I want to use the London and new york session as my kill zone to trade what ever time it will be on my server i want it to be converted automatically to my server time how can we do this
 //and what time would be the best for gold trading?


